
libname ssr 'E:\Users\ssr180000\Downloads';

data vg_sales_basic;
set ssr.videogamesales_main;
run;

/* Question 1 - Part A */

proc glm data = vg_sales_cookd;
class Rating(ref='E10+') Platform(ref='PC') Genre(ref='Strategy');
model log_global_sales = Rating Platform Genre Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation Generation*Platform  / solution;
where cookd < 4/4155;
output out=vg_sales_safe;
run;
quit;


/* Question 1 - Part B */

proc glm data = vg_sales_basic PLOTS(UNPACK)=RESIDUALS;
class Rating(ref='E10+') Platform(ref='PC') Genre(ref='Strategy');
model Global_Sales = Rating Platform Genre Critic_Score User_Score User_Count Critic_Count Year_of_Release / solution;
run;
quit;

/* The joint effect of all the levels of Rating, Platforms and Genre can be observed from the anova table generated by above and we can
safely say that it is significant. But the R square is 0.179467 which is not good at all and needs improvement. */

/* Feature Engineering results are stored in vg_sales_fe */

proc sgplot data= vg_sales_basic;
 histogram Global_Sales; 
 density Global_Sales / type = kernel; 
 density Global_Sales; 
 title 'Global Scores';
run;

/*We can see that Y is highly skewed to the right. */

data vg_sales_basic;
set vg_sales_basic;
log_global_sales = log(Global_Sales);
run;

proc sort data=vg_sales_basic;
by Year_of_Release;
run;

proc freq data=vg_sales_basic;
table Platform * Year_of_Release;
run;

/* The results of the proc freq indicate that we can divide the years from 2001 to 2012 into 2 generations: 2001-2006 as 1st gen and
2007-2012 as 2nd gen */

data vg_sales_fe;
set vg_sales_basic;
IF Year_of_Release<=2006 THEN Generation =0; else Generation =1;
run;

/* Building a segment response model with interaction between Generation and Platform */

proc glm data = vg_sales_fe PLOTS(UNPACK)=RESIDUALS;
class Rating(ref='E10+') Platform(ref='PC') Genre(ref='Strategy');
model log_global_sales = Rating Platform Genre Critic_Score User_Score User_Count Critic_Count Generation Generation*Platform  / solution;
run;
quit;

/*rsqaure = 0.46*/

/*We modify the User_Score by multiplying it by 10 so that both are in the same scale of 0-100 and also calculate the weighted scores.*/

data vg_sales_fe;
set vg_sales_fe;
User_Score = User_Score*10;
Weighted_Score = (User_Score*User_Count + Critic_Score*Critic_Count)/User_Count+Critic_Count;
run;

proc corr data=vg_sales_fe plots=matrix;
var log_global_sales Critic_Score User_Score User_Count Critic_Count Weighted_Score;
run;

/* We can see that there is a slight correlation among the User_Scores and Critic Scores. */

proc sgplot data= vg_sales_fe;
 histogram User_Score; 
 density User_Score / type = kernel; 
 density User_Score; 
run;

proc sgplot data= vg_sales_fe;
 histogram Critic_Score; 
 density Critic_Score / type = kernel; 
 density Critic_Score; 
run;

/* get rid of the extreme outliers - beyond 2 sd*/

data vg_sales_fe;
set vg_sales_fe;
if User_Score >45;
if Critic_Score >32;
run;

proc stdize data=vg_sales_fe out=vg_sales_fe;
var Critic_Score User_Score;
run;

proc sgplot data= vg_sales_fe;
 histogram Critic_Score; 
 density Critic_Score / type = kernel; 
 density Critic_Score; 
run;

proc glm data = vg_sales_fe PLOTS(UNPACK)=RESIDUALS;
class Rating(ref='E10+') Platform(ref='PC') Genre(ref='Strategy');
model log_global_sales = Rating Platform Genre Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation Generation*Platform  / solution;
run;
quit;

/*rsqaure = 0.521622*/

/* Ideally if the user scores are high then the global sales should also be high. But the coefficient has a negative sign which is
strange. Thus we haven't yet handled the influential points */

proc glm data = vg_sales_fe PLOTS(UNPACK)=RESIDUALS;
class Rating(ref='E10+') Platform(ref='PC') Genre(ref='Strategy');
model log_global_sales = Rating Platform Genre Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation Generation*Platform  / solution;
output out=vg_sales_cookd cookd=cookd student=sresiduals;
run;
quit;

Proc print data=vg_sales_cookd;
var _All_;
Where cookd >4/4155;
run;

/* One way to handle these outliers will be to drop these points and then estimating the model */
proc glm data = vg_sales_cookd;
class Rating(ref='E10+') Platform(ref='PC') Genre(ref='Strategy');
model log_global_sales = Rating Platform Genre Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation Generation*Platform  / solution;
where cookd < 4/4155;
output out=vg_sales_safe;
run;
quit;

proc sgplot data =vg_sales_cookd;
reg y=Global_Sales x=User_Score;
scatter y=Global_Sales x=User_Score;
where cookd < 4/4155;
run;

/*rsqaure = 0.614459 */

data vg_sales_reg;
set vg_sales_cookd;
/*Considering the base case as E10+ */
IF Rating = "T" THEN Rating_T=1;  ELSE Rating_T=0;
IF Rating = "M" THEN Rating_M=1;  ELSE Rating_M=0;
IF Rating = "E" THEN Rating_E=1;  ELSE Rating_E=0;
/*Considering the base case as Strategy */
IF Genre = "Action" THEN Genre_Action=1;  ELSE Genre_Action=0;
IF Genre = "Adventure" THEN Genre_Adventure=1;  ELSE Genre_Adventure=0;
IF Genre = "Fighting" THEN Genre_Fighting=1;  ELSE Genre_Fighting=0;
IF Genre = "Misc" THEN Genre_Misc=1;  ELSE Genre_Misc=0;
IF Genre = "Platform" THEN Genre_Platform=1;  ELSE Genre_Platform=0;
IF Genre = "Puzzle" THEN Genre_Puzzle=1;  ELSE Genre_Puzzle=0;
IF Genre = "Racing" THEN Genre_Racing=1;  ELSE Genre_Racing=0;
IF Genre = "Role-Playing" THEN Genre_RolePlaying=1;  ELSE Genre_RolePlaying=0;
IF Genre = "Shooter" THEN Genre_Shooter=1;  ELSE Genre_Shooter=0;
IF Genre = "Simulation" THEN Genre_Simulation=1;  ELSE Genre_Simulation=0;
IF Genre = "Strategy" THEN Genre_Strategy=1;  ELSE Genre_Strategy=0;
/*Considering the base case as PC */
IF Platform = "DS" THEN Platform_DS=1;  ELSE Platform_DS=0;
IF Platform = "GBA" THEN Platform_GBA=1;  ELSE Platform_GBA=0;
IF Platform = "GC" THEN Platform_GC=1;  ELSE Platform_GC=0;
IF Platform = "XB" THEN Platform_XB=1;  ELSE Platform_XB=0;
IF Platform = "PS2" THEN Platform_PS2=1;  ELSE Platform_PS2=0;
IF Platform = "PS3" THEN Platform_PS3=1;  ELSE Platform_PS3=0;
IF Platform = "PSP" THEN Platform_PSP=1;  ELSE Platform_PSP=0;
IF Platform = "Wii" THEN Platform_Wii=1;  ELSE Platform_Wii=0;
IF Platform = "X360" THEN Platform_X360=1;  ELSE Platform_X360=0;
run;

/* Let us use robust regression to adjust the weights instead of dropping the variables */

proc robustreg data = vg_sales_reg fwls method=m;
model log_global_sales = Rating_: Platform_: Genre_: Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation;
output out=vg_sales_robust weight = wgt outlier = ol;
run;
quit;

/* Detection and Handling of Multicollinearity with vif */

proc reg data = vg_sales_reg;
model log_global_sales = Rating_: Platform_: Genre_: Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation /
collinoint vif;
run;
quit;

/* we observe that all the values of vif are less than 10 indicating that there is not much multicollinearity in the dataset and
the condition index is less than 10 for all eigen values meaning that they have a weak effect even if they do. Hence instead of 
using the PCA as our dependednt variables we keep the variables as it is */

/* Handling Heteroscedasticity */

proc reg data = vg_sales_reg ;
model log_global_sales = Rating_: Platform_: Genre_: Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation /
hcc spec;
run;
quit;

/* 1. From the whites test we can see that since the p value is very very small and highly significant 
2. The heteroscedasticity consistent standard errors and t-values are higher than original values
Thus we reject the null hypothesis that all regression assumptions are satisfied and prove the presence of heteroscedasticity. */

proc model data=vg_sales_reg;
log_global_sales = a1 + b1*Rating_T+ c1*Rating_M +d1*Rating_E +e1*Weighted_Score+ f1*Critic_Score+ g1*User_Score+h1*User_Count+ i1*Critic_Count+
j1*Genre_Action+ k1*Genre_Adventure+l1*Genre_Fighting+ m1*Genre_Misc+ n1*Genre_Platform+o1*Genre_Puzzle+ p1*Genre_Racing+ q1*Genre_RolePlaying+
r1*Genre_Shooter +s1*Genre_Simulation+ t1*Genre_Strategy+ u1*Platform_DS+ v1*Platform_GBA +w1*Platform_GC +x1*Platform_XB +y1*Platform_PS2 +z1*Platform_PS3 +
zz1*Platform_PSP +zx1*Platform_Wii+ zc1*Platform_X360+ zv1*Generation;
fit log_global_sales / white;
run;
quit;

/* test for normality of errors */

proc univariate data = vg_sales_reg normal;
var sresiduals;
histogram sresiduals / normal kernel; 
run;

/* Looking at the Goodness-of-Fit Tests for Normal Distribution we can clearly state that no matter which test we perform, the 
pvalues are all significant hence we reject the null that the distribution is normal. */

proc univariate data = vg_sales_reg normal;
var sresiduals;
histogram sresiduals / normal kernel; 
where cookd < 4/4155;
run;

PROC REG DATA=vg_sales_reg;
model log_global_sales = Rating_: Platform_: Genre_: Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation 
/SPEC WHITE R VIF ;
OUTPUT OUT=residuals RESIDUAL=sresiduals;
PLOT RESIDUAL.*PREDICTED. ;
PLOT RESIDUAL.*NQQ.;
RUN;

proc AutoREG data=vg_sales_reg;
model log_global_sales = Rating_: Platform_: Genre_: Weighted_Score Critic_Score User_Score User_Count Critic_Count Generation 
/dw=4 dwprob;
RUN;
quit;








